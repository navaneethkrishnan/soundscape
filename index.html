‡¥ï‡µç‡¥∑‡¥Æ‡¥ø‡¥ï‡µç‡¥ï‡¥£‡¥Ç, ‡¥§‡¥æ‡¥ô‡µç‡¥ï‡¥≥‡µÅ‡¥ü‡µÜ ‡¥Ü‡¥µ‡¥∂‡µç‡¥Ø‡¥Ç ‡¥á‡¥™‡µç‡¥™‡µã‡µæ ‡¥ï‡µÉ‡¥§‡µç‡¥Ø‡¥Æ‡¥æ‡¥Ø‡¥ø ‡¥Æ‡¥®‡¥∏‡µç‡¥∏‡¥ø‡¥≤‡¥æ‡¥Ø‡¥ø.

‡¥ì‡¥°‡¥ø‡¥Ø‡µã ‡¥´‡¥Ø‡µΩ ‡¥µ‡µá‡¥±‡µÜ ‡¥∏‡µÇ‡¥ï‡µç‡¥∑‡¥ø‡¥ï‡µç‡¥ï‡¥æ‡¥§‡µÜ, **‡¥∂‡¥¨‡µç‡¥¶‡¥§‡µç‡¥§‡µÜ ‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥Æ‡¥æ‡¥ï‡µç‡¥ï‡¥ø ‡¥Æ‡¥æ‡¥±‡µç‡¥±‡µÅ‡¥ï‡¥Ø‡µÅ‡¥Ç (Spectrogram), ‡¥Ü ‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥§‡µç‡¥§‡¥ø‡¥≤‡µÜ ‡¥®‡¥ø‡¥±‡¥ô‡µç‡¥ô‡¥≥‡µÜ ‡¥§‡¥ø‡¥∞‡¥ø‡¥ö‡µç‡¥ö‡µç ‡¥∂‡¥¨‡µç‡¥¶‡¥Æ‡¥æ‡¥ï‡µç‡¥ï‡¥ø ‡¥Æ‡¥æ‡¥±‡µç‡¥±‡µÅ‡¥ï‡¥Ø‡µÅ‡¥Ç (Inverse Spectrogram/Sonification)** ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥® ‡¥™‡¥¥‡¥Ø ‡¥∞‡µÄ‡¥§‡¥ø ‡¥§‡¥®‡µç‡¥®‡µÜ ‡¥Æ‡¥§‡¥ø. ‡¥é‡¥®‡µç‡¥®‡¥æ‡µΩ ‡¥Ö‡¥§‡¥ø‡µΩ ‡¥®‡¥Æ‡µç‡¥Æ‡µæ ‡¥Ü‡¥¶‡µç‡¥Ø‡¥Ç ‡¥™‡¥±‡¥û‡µç‡¥û ‡¥é‡¥≤‡µç‡¥≤‡¥æ ‡¥´‡µÄ‡¥ö‡µç‡¥ö‡¥±‡µÅ‡¥ï‡¥≥‡µÅ‡¥Ç (‡¥§‡µÅ‡¥ü‡µº‡¥ö‡µç‡¥ö‡¥Ø‡¥æ‡¥Ø ‡¥∏‡µç‡¥ï‡¥æ‡¥®‡¥ø‡¥Ç‡¥ó‡µç, 15 ‡¥∏‡µÜ‡¥ï‡µç‡¥ï‡µª‡¥°‡¥ø‡µΩ ‡¥ì‡¥ü‡µç‡¥ü‡µã ‡¥∏‡µá‡¥µ‡µç, ‡¥µ‡¥æ‡¥ü‡µç‡¥ü‡µº‡¥Æ‡¥æ‡µº‡¥ï‡µç‡¥ï‡µç) ‡¥µ‡µá‡¥£‡¥Ç.

‡¥§‡¥æ‡¥¥‡µÜ ‡¥®‡µΩ‡¥ï‡¥ø‡¥Ø‡¥ø‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡µç ‡¥á‡¥§‡¥ø‡¥®‡¥æ‡¥Ø‡µÅ‡¥≥‡µç‡¥≥ ‡¥è‡¥±‡µç‡¥±‡¥µ‡µÅ‡¥Ç ‡¥ï‡µÉ‡¥§‡µç‡¥Ø‡¥Æ‡¥æ‡¥Ø ‡¥ï‡µã‡¥°‡¥æ‡¥£‡µç.

### ‡¥á‡¥§‡¥ø‡¥®‡µç‡¥±‡µÜ ‡¥™‡µç‡¥∞‡¥§‡µç‡¥Ø‡µá‡¥ï‡¥§‡¥ï‡µæ:

1. **‡¥∂‡¥¨‡µç‡¥¶‡¥Ç ‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥Æ‡¥æ‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ:** ‡¥Æ‡µà‡¥ï‡µç‡¥ï‡¥ø‡¥≤‡µÇ‡¥ü‡µÜ ‡¥µ‡¥∞‡µÅ‡¥®‡µç‡¥® ‡¥∂‡¥¨‡µç‡¥¶‡¥Ç ‡¥§‡¥§‡µç‡¥∏‡¥Æ‡¥Ø‡¥Ç ‡¥®‡¥ø‡¥±‡¥ô‡µç‡¥ô‡¥≥‡¥æ‡¥Ø‡¥ø ‡¥Æ‡¥æ‡¥±‡µÅ‡¥®‡µç‡¥®‡µÅ.
2. **‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥Ç ‡¥∂‡¥¨‡µç‡¥¶‡¥Æ‡¥æ‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ:** ‡¥á‡¥§‡¥ø‡µΩ **‡¥ì‡¥°‡¥ø‡¥Ø‡µã ‡¥´‡¥Ø‡µΩ ‡¥∏‡µá‡¥µ‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡¥ø‡¥≤‡µç‡¥≤**. ‡¥®‡¥ø‡¥ô‡µç‡¥ô‡µæ ‡¥∏‡µá‡¥µ‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥§ ‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥Ç ‡¥§‡¥ø‡¥∞‡¥ø‡¥ï‡µÜ ‡¥Ö‡¥™‡µç‚Äå‡¥≤‡µã‡¥°‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥Æ‡µç‡¥™‡µã‡µæ, ‡¥Ü ‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥§‡µç‡¥§‡¥ø‡¥≤‡µÜ ‡¥®‡¥ø‡¥±‡¥ô‡µç‡¥ô‡¥≥‡µÜ ‡¥ï‡¥Æ‡µç‡¥™‡µç‡¥Ø‡µÇ‡¥ü‡µç‡¥ü‡µº ‡¥µ‡¥æ‡¥Ø‡¥ø‡¥ö‡µç‡¥ö‡µç ‡¥Ö‡¥§‡¥ø‡¥®‡µÜ ‡¥§‡¥ø‡¥∞‡¥ø‡¥ö‡µç‡¥ö‡µç ‡¥∂‡¥¨‡µç‡¥¶‡¥§‡¥∞‡¥Ç‡¥ó‡¥ô‡µç‡¥ô‡¥≥‡¥æ‡¥ï‡µç‡¥ï‡¥ø ‡¥Æ‡¥æ‡¥±‡µç‡¥±‡µÅ‡¥ï‡¥Ø‡¥æ‡¥£‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡¥§‡µç. (‡¥Ö‡¥§‡µÅ‡¥ï‡µä‡¥£‡µç‡¥ü‡¥æ‡¥£‡µç ‡¥á‡¥§‡µç ‡¥±‡µã‡¥¨‡µã‡¥ü‡µç‡¥ü‡¥ø‡¥ï‡µç ‡¥Ü‡¥Ø‡¥ø ‡¥ï‡µá‡µæ‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡µç, ‡¥™‡¥ï‡µç‡¥∑‡µá ‡¥á‡¥§‡µç ‡¥™‡µÇ‡µº‡¥£‡µç‡¥£‡¥Æ‡¥æ‡¥Ø‡µÅ‡¥Ç ‡¥Ü ‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥§‡µç‡¥§‡¥ø‡µΩ ‡¥®‡¥ø‡¥®‡µç‡¥®‡µç ‡¥Æ‡¥æ‡¥§‡µç‡¥∞‡¥Æ‡¥æ‡¥£‡µç ‡¥µ‡¥∞‡µÅ‡¥®‡µç‡¥®‡¥§‡µç).
3. **Auto-Loop & Save:** 15 ‡¥∏‡µÜ‡¥ï‡µç‡¥ï‡µª‡¥°‡µç ‡¥ï‡µÇ‡¥ü‡µÅ‡¥Æ‡µç‡¥™‡µã‡µæ ‡¥ï‡¥±‡¥ï‡µç‡¥ï‡¥Ç ‡¥™‡µÇ‡µº‡¥§‡µç‡¥§‡¥ø‡¥Ø‡¥æ‡¥ï‡µç‡¥ï‡¥ø ‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥Ç ‡¥ó‡¥æ‡¥≤‡¥±‡¥ø‡¥Ø‡¥ø‡µΩ ‡¥µ‡¥∞‡µÅ‡¥Ç, ‡¥∏‡µç‡¥ï‡¥æ‡¥®‡¥ø‡¥Ç‡¥ó‡µç ‡¥§‡µÅ‡¥ü‡µº‡¥®‡µç‡¥®‡µÅ‡¥ï‡µä‡¥£‡µç‡¥ü‡µá‡¥Ø‡¥ø‡¥∞‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥Ç.
4. **Watermark:** ‡¥ö‡¥ø‡¥§‡µç‡¥∞‡¥§‡µç‡¥§‡¥ø‡µΩ ‡¥∏‡¥Æ‡¥Ø‡¥Ç, ‡¥§‡µÄ‡¥Ø‡¥§‡¥ø, ‡¥≤‡¥ø‡¥ô‡µç‡¥ï‡µç ‡¥é‡¥®‡µç‡¥®‡¥ø‡¥µ ‡¥â‡¥£‡µç‡¥ü‡¥æ‡¥ï‡µÅ‡¥Ç.

‡¥á‡¥§‡µç ‡¥ï‡µã‡¥™‡µç‡¥™‡¥ø ‡¥ö‡µÜ‡¥Ø‡µç‡¥§‡µç ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥ø‡¥ï‡µç‡¥ï‡µÇ:

```html
<!DOCTYPE html>
<html lang="ml">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Soundscape Engine</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: 'Segoe UI', monospace; display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
        
        /* RADAR DISPLAY */
        .radar-wrapper {
            position: relative; margin-top: 20px;
            width: 95vw; height: 95vw; max-width: 600px; max-height: 600px;
            border-radius: 50%; border: 2px solid #333; background: #000;
            overflow: hidden; box-shadow: 0 0 40px rgba(0, 255, 0, 0.1);
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* CONTROLS */
        .controls {
            margin: 15px; padding: 15px; background: #111; border-radius: 12px;
            display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;
            width: 90%; max-width: 600px; border: 1px solid #222;
        }
        button { padding: 10px 20px; font-size: 14px; border: none; border-radius: 5px; cursor: pointer; color: white; font-weight: bold; }
        .btn-rec { background: #e74c3c; }
        .btn-pause { background: #f39c12; }
        .btn-play { background: #27ae60; }
        .btn-stop { background: #7f8c8d; }
        
        #status { color: #0f0; margin-bottom: 5px; font-size: 13px; }
        
        /* SCAN LINE (PLAYBACK) */
        #scanLine {
            position: absolute; top: 50%; left: 50%; width: 50%; height: 2px;
            background: #fff; transform-origin: 0 0; display: none; pointer-events: none;
            box-shadow: 0 0 10px white; z-index: 10;
        }

        /* GALLERY */
        #gallery {
            width: 95%; max-width: 600px; margin-bottom: 50px; margin-top: 20px;
            display: flex; flex-direction: column; gap: 15px;
        }
        .gallery-item {
            background: #1a1a1a; border: 1px solid #333; padding: 10px; border-radius: 8px;
            display: flex; gap: 15px; align-items: center; animation: fadeIn 0.5s;
        }
        .gallery-item img {
            width: 80px; height: 80px; object-fit: cover; border-radius: 4px; border: 1px solid #555; cursor: pointer;
        }
        .gallery-info { flex: 1; font-size: 12px; color: #aaa; }
        .gallery-actions a {
            display: inline-block; background: #333; color: white; text-decoration: none;
            padding: 5px 15px; border-radius: 4px; margin-top: 5px; font-size: 11px;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <div class="controls">
        <button class="btn-rec" id="startBtn">üé§ Start Scan</button>
        <button class="btn-pause" id="pauseBtn" style="display:none;">‚è∏ Pause</button>
        <button class="btn-play" id="resumeBtn" style="display:none;">‚ñ∂ Resume</button>
        
        <div style="width:1px; background:#333; margin:0 5px;"></div>
        
        <button class="btn-play" onclick="document.getElementById('fileInput').click()">üìÇ Upload Image & Play</button>
        <button class="btn-stop" id="stopBtn" style="display:none;">‚èπ Stop Playing</button>
        <input type="file" id="fileInput" accept="image/*" style="display:none">
    </div>

    <div id="status">Ready. Image-to-Sound Engine.</div>

    <div class="radar-wrapper">
        <canvas id="radar" width="1000" height="1000"></canvas>
        <div id="scanLine"></div>
    </div>

    <h3 style="color:#444; font-size:12px; text-transform:uppercase; margin-top:20px;">Gallery (Auto-Saved)</h3>
    <div id="gallery"></div>

    <script>
        // --- CONFIGURATION ---
        const SCAN_DURATION_MS = 15000; // 15 Seconds per loop
        const SCAN_SPEED = (Math.PI * 2) / (SCAN_DURATION_MS / 16.66); // Angle per frame

        // --- ELEMENTS ---
        const canvas = document.getElementById('radar');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const status = document.getElementById('status');
        const scanLine = document.getElementById('scanLine');
        const gallery = document.getElementById('gallery');
        
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resumeBtn = document.getElementById('resumeBtn');
        const stopBtn = document.getElementById('stopBtn');

        // --- VARIABLES ---
        let audioCtx, analyser, dataArray, source, stream;
        let isScanning = false;
        let isPaused = false;
        let isPlaying = false;
        let angle = 0;
        let animationId;
        let loadedImageData = null; // For playback
        let oscs = []; // Oscillators for synthesis

        // Initialize
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // ==========================================
        // 1. SCANNING (RECORDING) LOGIC
        // ==========================================

        startBtn.onclick = async () => {
            stopPlayback();
            try {
                if (!stream) {
                    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                }
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                
                source = audioCtx.createMediaStreamSource(stream);
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 4096; // High detail
                analyser.smoothingTimeConstant = 0.3;
                source.connect(analyser);
                
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                // UI Reset
                startBtn.style.display = 'none';
                pauseBtn.style.display = 'inline-block';
                status.textContent = "Scanning... (Auto-saves every 15s)";
                
                angle = 0;
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                isScanning = true;
                isPaused = false;
                loopScan();

            } catch (err) {
                alert("Microphone Access Error: " + err.message);
            }
        };

        pauseBtn.onclick = () => { isPaused = true; updatePauseUI(); };
        resumeBtn.onclick = () => { isPaused = false; updatePauseUI(); };

        function updatePauseUI() {
            pauseBtn.style.display = isPaused ? 'none' : 'inline-block';
            resumeBtn.style.display = isPaused ? 'inline-block' : 'none';
            status.textContent = isPaused ? "Paused." : "Scanning...";
        }

        function loopScan() {
            if (!isScanning) return;
            animationId = requestAnimationFrame(loopScan);
            if (isPaused) return;

            analyser.getByteFrequencyData(dataArray);

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const maxRadius = cx;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(angle);

            // DRAWING LOGIC (Logarithmic Scale)
            const startBin = 5;
            const endBin = dataArray.length * 0.8;
            const totalBins = endBin - startBin;

            // Draw thicker line to fill gaps
            const barWidth = (Math.PI * 2 * maxRadius) / (SCAN_DURATION_MS / 16.66) * 1.5;

            for (let r = 0; r < maxRadius; r += 2) {
                const percent = r / maxRadius;
                // Logarithmic mapping: Low freq at center, High at edge
                const logIndex = startBin + (totalBins * (Math.pow(100, percent) - 1) / 99);
                const index = Math.floor(logIndex);
                const value = dataArray[index] || 0;

                if (value > 10) { // Noise gate
                    const hue = 270 - (percent * 270); // Violet -> Red
                    const lightness = 5 + (value / 255) * 60; // Brightness
                    
                    ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                    // Draw pixel
                    ctx.fillRect(r, -2, 4, 4);
                }
            }
            
            // Scanner Head Visual
            ctx.fillStyle = '#fff';
            ctx.fillRect(maxRadius - 10, -1, 10, 2);
            
            ctx.restore();

            angle += SCAN_SPEED;

            // CHECK 15 SECONDS (Full Rotation)
            if (angle >= Math.PI * 2) {
                processAndSave(); // Save to gallery
                angle = 0; // Reset
                ctx.fillStyle = '#000'; // Wipe canvas
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // ==========================================
        // 2. SAVING LOGIC (WATERMARK)
        // ==========================================

        function processAndSave() {
            // Create temp canvas for watermark
            const tempCanvas = document.createElement('canvas');
            const footerH = 150;
            tempCanvas.width = 1000;
            tempCanvas.height = 1000 + footerH;
            const tCtx = tempCanvas.getContext('2d');

            tCtx.fillStyle = '#000';
            tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            tCtx.drawImage(canvas, 0, 0);

            // Watermark Info
            const now = new Date();
            const timeStr = now.toLocaleTimeString();
            const dateStr = now.toLocaleDateString();

            tCtx.textAlign = 'center';
            tCtx.fillStyle = '#fff';
            tCtx.font = 'bold 40px monospace';
            tCtx.fillText(`${dateStr} | ${timeStr}`, 500, 1060);
            
            tCtx.fillStyle = '#888';
            tCtx.font = '24px sans-serif';
            tCtx.fillText(window.location.href, 500, 1110);

            const imgUrl = tempCanvas.toDataURL('image/jpeg', 0.85);
            addToGallery(imgUrl, timeStr);
        }

        function addToGallery(url, time) {
            const div = document.createElement('div');
            div.className = 'gallery-item';
            div.innerHTML = `
                <img src="${url}" title="Click to Play">
                <div class="gallery-info">
                    <strong>Recorded: ${time}</strong><br>
                    <span>Duration: 15s Loop</span><br>
                    <span style="color:#2ecc71">‚ñ∂ Click image to Synthesize Audio</span>
                </div>
                <div class="gallery-actions">
                    <a href="${url}" download="soundscape_${Date.now()}.jpg">üíæ Save Image</a>
                </div>
            `;
            // Click image to play
            div.querySelector('img').onclick = () => loadAndPlay(url);
            gallery.prepend(div);
        }

        // ==========================================
        // 3. PLAYBACK LOGIC (IMAGE -> SOUND)
        // ==========================================

        document.getElementById('fileInput').onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (evt) => loadAndPlay(evt.target.result);
                reader.readAsDataURL(file);
            }
        };

        function loadAndPlay(src) {
            if (isScanning) {
                isScanning = false;
                cancelAnimationFrame(animationId);
                startBtn.style.display = 'inline-block';
                pauseBtn.style.display = 'none';
            }

            const img = new Image();
            img.onload = () => {
                // Clear and Draw image to canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                // Get pixel data for sound synthesis
                loadedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                startPlayback();
            };
            img.src = src;
        }

        function startPlayback() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            isPlaying = true;
            stopBtn.style.display = 'inline-block';
            scanLine.style.display = 'block';
            status.textContent = "Synthesizing Sound from Image Data...";

            const startTime = performance.now();

            function playLoop() {
                if (!isPlaying) return;
                
                const elapsed = performance.now() - startTime;
                // Loop 15s
                const progress = (elapsed % SCAN_DURATION_MS) / SCAN_DURATION_MS;
                const currentAngle = progress * Math.PI * 2;

                // Visual
                scanLine.style.transform = `translate(-50%, -50%) rotate(${progress * 360}deg) translate(50%, 0)`;

                // Audio Synthesis
                synthesizeFromImage(currentAngle);

                requestAnimationFrame(playLoop);
            }
            playLoop();
        }

        function synthesizeFromImage(angle) {
            // Cleanup old oscillators (Simple synthesis method)
            // Note: For smoother sound, a oscillator bank is better, but this fits the single-file constraint nicely.
            oscs.forEach(o => { 
                try { o.stop(); o.disconnect(); } catch(e){} 
            });
            oscs = [];

            if (!loadedImageData) return;

            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const maxRadius = cx;
            const pixels = loadedImageData.data;

            // Sample resolution (Lower = faster/robotic, Higher = detailed/slow)
            const steps = 40; 

            for (let i = 1; i < steps; i++) {
                const percent = i / steps;
                const r = percent * maxRadius;

                // Calculate X,Y for this angle and radius
                const x = Math.floor(cx + Math.cos(angle) * r);
                const y = Math.floor(cy + Math.sin(angle) * r);

                // Bounds check
                if (x < 0 || x >= 1000 || y < 0 || y >= 1000) continue;

                const pIndex = (y * 1000 + x) * 4;
                const red = pixels[pIndex];
                const green = pixels[pIndex + 1];
                const blue = pixels[pIndex + 2];
                const brightness = (red + green + blue) / 3;

                // If pixel has data (sound)
                if (brightness > 20) {
                    // Inverse Log Mapping: Recover Frequency from Radius
                    // Frequency increases exponentially with radius
                    const frequency = 50 + (Math.pow(100, percent) * 180); 

                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();

                    // Using 'triangle' wave for a slightly richer sound than 'sine'
                    osc.type = 'triangle'; 
                    osc.frequency.value = frequency;
                    
                    // Volume based on pixel brightness
                    gain.gain.value = (brightness / 255) * 0.02; // Keep volume low to prevent clipping

                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start();
                    // Stop very shortly to create the "scan" effect
                    osc.stop(audioCtx.currentTime + 0.05);
                    
                    oscs.push(osc);
                }
            }
        }

        function stopPlayback() {
            isPlaying = false;
            stopBtn.style.display = 'none';
            scanLine.style.display = 'none';
            oscs.forEach(o => { try { o.stop(); } catch(e){} });
            status.textContent = "Ready.";
        }
        
        stopBtn.onclick = stopPlayback;

    </script>
</body>
</html>

```
