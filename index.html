<!DOCTYPE html>
<html lang="ml">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soundscape Pro (Steganography)</title>
    <style>
        body { margin: 0; background: #050505; color: #fff; font-family: monospace; display: flex; flex-direction: column; align-items: center; min-height: 100vh; }
        
        .radar-box {
            position: relative; margin-top: 15px;
            width: 95vw; height: 95vw; max-width: 500px; max-height: 500px;
            border-radius: 50%; border: 4px solid #333; background: #000;
            overflow: hidden; box-shadow: 0 0 25px rgba(0,255,0,0.1);
        }
        canvas { display: block; width: 100%; height: 100%; }

        .controls {
            margin: 15px; padding: 12px; background: #111; border-radius: 12px;
            display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; width: 95%; max-width: 600px;
        }
        button { padding: 10px 18px; font-size: 13px; border: none; border-radius: 5px; cursor: pointer; color: white; font-weight: bold; }
        .btn-rec { background: #e74c3c; }
        .btn-stop { background: #7f8c8d; }
        .btn-up { background: #27ae60; }
        
        #status { color: #f1c40f; margin-bottom: 5px; font-size: 12px; }
        
        /* Playback Scan Line */
        #scanLine {
            position: absolute; top: 50%; left: 50%; width: 50%; height: 2px;
            background: #fff; transform-origin: 0 0; display: none; pointer-events: none;
            box-shadow: 0 0 8px white; z-index: 10;
        }

        /* Gallery */
        #gallery { width: 95%; max-width: 600px; margin-bottom: 60px; display: flex; flex-direction: column; gap: 15px; }
        .item { background: #1a1a1a; border: 1px solid #333; padding: 10px; border-radius: 8px; display: flex; gap: 12px; align-items: center; }
        .item img { width: 80px; height: 80px; object-fit: cover; border: 1px solid #555; cursor: pointer; border-radius: 4px; }
        .info { font-size: 11px; color: #aaa; flex: 1; }
        .btn-dl { display: inline-block; background: #333; color: white; text-decoration: none; padding: 6px 12px; border-radius: 4px; margin-top: 6px; font-size: 11px; border: 1px solid #555; }
    </style>
</head>
<body>

    <div class="controls">
        <button class="btn-rec" id="startBtn">üî¥ Start Loop</button>
        <button class="btn-stop" id="stopBtn" style="display:none;">‚èπ Stop Playback</button>
        <button class="btn-up" onclick="document.getElementById('fileIn').click()">üìÇ Upload & Play</button>
        <input type="file" id="fileIn" accept="image/png" style="display:none">
    </div>

    <div id="status">Ready.</div>

    <div class="radar-box">
        <canvas id="radar" width="800" height="800"></canvas>
        <div id="scanLine"></div>
    </div>

    <h3 style="color:#444; font-size:11px; margin-top:20px;">SAVED LOOPS</h3>
    <div id="gallery"></div>

    <script>
        const LOOP_MS = 15000;
        const SPEED = (Math.PI * 2) / (LOOP_MS / 16.66);

        const canvas = document.getElementById('radar');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const scanLine = document.getElementById('scanLine');
        const status = document.getElementById('status');
        const gallery = document.getElementById('gallery');

        let audioCtx, analyser, dataArray, stream;
        let recorder, chunks = [];
        let isRec = false, angle = 0, animId;
        let player = null;
        let tempSnap = null;

        // Init Canvas
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,800,800);

        // --- 1. RECORDING LOOP ---
        startBtn.onclick = async () => {
            if(player) stopPlayback();
            try {
                if(!stream) stream = await navigator.mediaDevices.getUserMedia({audio:true});
                
                // Visual Setup
                if(!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const src = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 2048;
                    src.connect(analyser);
                    dataArray = new Uint8Array(analyser.frequencyBinCount);
                }

                // Recorder Setup
                recorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                chunks = [];
                recorder.ondataavailable = e => { if(e.data.size>0) chunks.push(e.data); };
                
                recorder.onstop = () => {
                    const blob = new Blob(chunks, {type:'audio/webm'});
                    chunks = [];
                    // Process using the snapshot
                    if(tempSnap) processToImage(blob, tempSnap);
                };

                startBtn.style.display = 'none';
                status.textContent = "Recording... (Looping)";
                
                isRec = true; 
                angle = 0;
                ctx.fillStyle='#000'; ctx.fillRect(0,0,800,800);
                
                recorder.start();
                loopDraw();

            } catch(e) { alert("Mic Error: "+e); }
        };

        function loopDraw() {
            if(!isRec) return;
            animId = requestAnimationFrame(loopDraw);

            analyser.getByteFrequencyData(dataArray);

            const cx = 400, cy = 400, maxR = 390;
            
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(angle);

            const len = dataArray.length * 0.75;
            for(let r=0; r<maxR; r+=4) {
                const percent = r/maxR;
                const idx = Math.floor(5 + (len * (Math.pow(100, percent) - 1) / 99));
                const val = dataArray[idx] || 0;

                if(val > 10) {
                    const hue = 270 - (percent*270);
                    const light = 5 + (val/255)*65;
                    ctx.fillStyle = `hsl(${hue}, 100%, ${light}%)`;
                    ctx.fillRect(r, -2, 6, 6);
                }
            }
            ctx.fillStyle='#fff'; ctx.fillRect(maxR-10, -1, 10, 2);
            ctx.restore();

            angle += SPEED;

            // LOOP END
            if(angle >= Math.PI*2) {
                // 1. Snapshot BEFORE wipe
                const snap = document.createElement('canvas');
                snap.width = 800; snap.height = 800;
                snap.getContext('2d').drawImage(canvas, 0, 0);
                tempSnap = snap; 

                // 2. Stop Recorder
                recorder.stop(); 

                // 3. Reset
                angle = 0;
                ctx.fillStyle='#000'; ctx.fillRect(0,0,800,800);

                // 4. Restart
                setTimeout(() => { if(isRec) recorder.start(); }, 50);
            }
        }

        // --- 2. ROBUST ENCODING (Pixels) ---
        function processToImage(blob, visualSnap) {
            const reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onloadend = () => {
                const b64 = reader.result;
                embedData(visualSnap, b64);
            };
        }

        function embedData(imgCvs, b64) {
            // New Canvas (800w x 1200h) - More space for data
            const final = document.createElement('canvas');
            const dataH = 400; // Large data area
            final.width = 800; final.height = 800 + dataH;
            const fCtx = final.getContext('2d');

            // Draw Visual
            fCtx.fillStyle='#000'; fCtx.fillRect(0,0,800, final.height);
            fCtx.drawImage(imgCvs, 0, 0);

            // Separator
            fCtx.fillStyle='#333'; fCtx.fillRect(0,800,800,2);
            fCtx.fillStyle='#fff'; fCtx.font='12px monospace'; fCtx.textAlign='center';
            fCtx.fillText("AUDIO DATA REGION - DO NOT CROP", 400, 815);

            // --- DIRECT PIXEL MAPPING ---
            // Prepare Data String: Length + Separator + Base64
            // We store the LENGTH of the string in the first few pixels to ensure we read back correctly.
            
            const fullString = b64;
            const dataLength = fullString.length;
            
            // Get Image Data for the data region
            // We start writing from y=820
            const startY = 820;
            const imgData = fCtx.createImageData(800, dataH - 20);
            const d = imgData.data;
            
            // Encode Length (first 4 pixels = 32 bit integer)
            // Storing length allows us to stop reading exactly where needed.
            d[0] = (dataLength >> 24) & 0xFF;
            d[1] = (dataLength >> 16) & 0xFF;
            d[2] = (dataLength >> 8) & 0xFF;
            d[3] = (dataLength & 0xFF);
            d[4] = 255; // Marker
            d[5] = 255;
            d[6] = 255;
            d[7] = 255;

            // Encode String
            let pixelIdx = 8; // Start after length header (4 pixels * 4 channels = 16 bytes, but we used 2 pixels)
            // Actually, imageData is R,G,B,A. 
            // We used 0-3 (Pixel 1) and 4-7 (Pixel 2). So data starts at index 8.

            for (let i = 0; i < dataLength; i++) {
                const charCode = fullString.charCodeAt(i);
                
                // Write into Red, Green, Blue channels sequentially for density
                // This fits 3 chars per pixel, or we can stay safe with 1 char per pixel channel.
                // Let's do 1 char per byte (channel).
                
                if (pixelIdx >= d.length) break; // Overflow protection
                
                d[pixelIdx] = charCode; // Write to current channel
                d[pixelIdx + 3] = 255; // Alpha must be 255
                
                pixelIdx++;
                
                // Skip Alpha channel (every 4th byte)
                if ((pixelIdx + 1) % 4 === 0) {
                    d[pixelIdx] = 255; // Set Alpha to opaque
                    pixelIdx++;
                }
            }

            // Put data back
            fCtx.putImageData(imgData, 0, startY);

            // Watermark
            const t = new Date().toLocaleTimeString();
            fCtx.fillStyle='#fff'; fCtx.font='20px monospace';
            fCtx.fillText(t, 400, final.height - 30);

            const url = final.toDataURL("image/png");
            addToGallery(url, t, b64);
        }

        function addToGallery(url, time, directAudio) {
            const div = document.createElement('div');
            div.className = 'item';
            div.innerHTML = `
                <img src="${url}">
                <div class="info">
                    <b>Rec: ${time}</b><br>
                    <span>Size: 15s Audio</span>
                </div>
                <a href="${url}" download="Soundscape_${Date.now()}.png" class="btn-dl">üíæ Save PNG</a>
            `;
            div.querySelector('img').onclick = () => {
                if(directAudio) playAudioString(directAudio); // Session Cache
                else playFromPixels(url); // Decode
            };
            gallery.prepend(div);
        }

        // --- 3. DECODING ---
        document.getElementById('fileIn').onchange = e => {
            const f = e.target.files[0];
            if(f) {
                const r = new FileReader();
                r.onload = ev => playFromPixels(ev.target.result);
                r.readAsDataURL(f);
            }
        };

        function playFromPixels(src) {
            stopPlayback();
            status.textContent = "Analyzing Pixels...";
            
            const img = new Image();
            img.crossOrigin = "Anonymous"; // Fix for some browsers
            img.onload = () => {
                // Prepare Canvas for reading
                const tC = document.createElement('canvas');
                tC.width = img.width; tC.height = img.height;
                const tX = tC.getContext('2d');
                // IMPORTANT: Disable smoothing to keep pixel values exact
                tX.imageSmoothingEnabled = false; 
                tX.drawImage(img, 0, 0);
                
                // Read from y=820
                const startY = 820;
                // Grab a large chunk
                const imgData = tX.getImageData(0, startY, img.width, 380); 
                const d = imgData.data;

                // 1. Read Length Header
                const len = (d[0] << 24) | (d[1] << 16) | (d[2] << 8) | d[3];
                
                if (len <= 0 || len > 2000000) { // Sanity check (max 2MB string)
                     alert("Could not detect valid audio header. Ensure this is the original PNG.");
                     status.textContent = "Error: Invalid Header";
                     return;
                }

                // 2. Read String
                let buffer = "";
                let pixelIdx = 8; // Start after header

                for (let i = 0; i < len; i++) {
                    // Skip Alpha channels while reading
                    if ((pixelIdx + 1) % 4 === 0) pixelIdx++;
                    
                    if (pixelIdx >= d.length) break;
                    
                    const charCode = d[pixelIdx];
                    buffer += String.fromCharCode(charCode);
                    pixelIdx++;
                }

                if (buffer.startsWith("data:audio")) {
                    playAudioString(buffer);
                } else {
                    alert("Data corrupted or not found.");
                }
            };
            img.src = src;
        }

        function playAudioString(b64) {
            try {
                player = new Audio(b64);
                player.play();
                scanLine.style.display='block';
                stopBtn.style.display='inline-block';
                status.textContent = "Playing Real Audio...";
                
                const startT = Date.now();
                function ani() {
                    if(!player || player.paused) return;
                    requestAnimationFrame(ani);
                    const p = ((Date.now()-startT)%LOOP_MS)/LOOP_MS;
                    scanLine.style.transform = `translate(-50%,-50%) rotate(${p*360}deg) translate(50%,0)`;
                }
                ani();
                player.onended = stopPlayback;
            } catch(e) {
                alert("Audio Playback Error: " + e);
            }
        }

        function stopPlayback() {
            if(player) player.pause();
            scanLine.style.display='none';
            stopBtn.style.display='none';
            status.textContent = "Ready.";
        }
        stopBtn.onclick = stopPlayback;

    </script>
</body>
</html>
